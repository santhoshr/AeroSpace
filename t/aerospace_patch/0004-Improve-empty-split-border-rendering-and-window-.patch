From 1abf77ebd6678e9ac59e529b10a3348d9260c28c Mon Sep 17 00:00:00 2001
From: santhoshr <santhoshr@live.com>
Date: Fri, 28 Feb 2025 00:08:48 +0530
Subject: [PATCH] Improve empty split border rendering and window targeting

---
 Sources/AppBundle/tree/EmptySplitVisual.swift | 73 ++++++++++++++++++-
 Sources/AppBundle/tree/MacWindow.swift        | 39 ++++++++++
 2 files changed, 109 insertions(+), 3 deletions(-)

diff --git a/Sources/AppBundle/tree/EmptySplitVisual.swift b/Sources/AppBundle/tree/EmptySplitVisual.swift
index b1bbb47..c2f8eab 100644
--- a/Sources/AppBundle/tree/EmptySplitVisual.swift
+++ b/Sources/AppBundle/tree/EmptySplitVisual.swift
@@ -34,8 +34,69 @@ class EmptySplitVisual {
         
         print("DEBUG: Showing border for split \(emptySplit.id) at \(frame.topLeftX), \(frame.topLeftY), \(frame.width)x\(frame.height)")
         
-        // Add simple highlight in parent view
-        if let window = NSApp.keyWindow {
+        // Try multiple approaches to find a window to add our border view to
+        var targetWindow: NSWindow?
+        
+        // First try: Use the key window
+        if let keyWindow = NSApp.keyWindow {
+            targetWindow = keyWindow
+        }
+        
+        // Second try: Find first visible window on the same screen
+        if targetWindow == nil {
+            let screenFrame = NSScreen.main?.frame ?? NSRect.zero
+            for window in NSApp.windows {
+                if window.isVisible && !window.isExcludedFromWindowsMenu && 
+                   NSIntersectsRect(window.frame, screenFrame) {
+                    targetWindow = window
+                    break
+                }
+            }
+        }
+        
+        // Third try: Create our own window if nothing else works
+        if targetWindow == nil {
+            let overlayWindow = NSWindow(
+                contentRect: NSRect(
+                    x: frame.topLeftX, 
+                    y: frame.topLeftY, 
+                    width: frame.width, 
+                    height: frame.height
+                ),
+                styleMask: [.borderless],
+                backing: .buffered,
+                defer: false
+            )
+            
+            overlayWindow.isReleasedWhenClosed = false
+            overlayWindow.level = .floating
+            overlayWindow.backgroundColor = .clear
+            overlayWindow.isOpaque = false
+            overlayWindow.hasShadow = false
+            overlayWindow.ignoresMouseEvents = true
+            
+            // Create view for the border in our custom window
+            let borderLayer = CALayer()
+            borderLayer.frame = NSRect(x: 0, y: 0, width: frame.width, height: frame.height)
+            borderLayer.borderWidth = borderWidth
+            borderLayer.borderColor = focusedBorderColor.cgColor
+            
+            let view = NSView(frame: NSRect(x: 0, y: 0, width: frame.width, height: frame.height))
+            view.wantsLayer = true
+            view.layer?.addSublayer(borderLayer)
+            
+            overlayWindow.contentView = view
+            overlayWindow.orderFront(nil)
+            
+            // Store reference
+            self.borderView = view
+            
+            print("DEBUG: Created custom overlay window for border")
+            return
+        }
+        
+        // If we found a window to use, add our border view to it
+        if let window = targetWindow {
             // Create view for the border
             let view = NSView(frame: NSRect(
                 x: frame.topLeftX, 
@@ -66,7 +127,7 @@ class EmptySplitVisual {
             
             print("DEBUG: Border view added to window")
         } else {
-            print("DEBUG: No key window available to add border")
+            print("DEBUG: No suitable window found to add border")
         }
     }
     
@@ -75,6 +136,12 @@ class EmptySplitVisual {
         if let view = borderView {
             print("DEBUG: Hiding border for split \(emptySplit.id)")
             view.removeFromSuperview()
+            // If we have a parent window that is our custom overlay, close it
+            if let parentWindow = view.window, 
+               parentWindow.styleMask == [.borderless], 
+               parentWindow.ignoresMouseEvents {
+                parentWindow.close()
+            }
             borderView = nil
         }
     }
diff --git a/Sources/AppBundle/tree/MacWindow.swift b/Sources/AppBundle/tree/MacWindow.swift
index 9da2ff2..41282ac 100644
--- a/Sources/AppBundle/tree/MacWindow.swift
+++ b/Sources/AppBundle/tree/MacWindow.swift
@@ -365,6 +365,45 @@ extension Window {
 
 // The function is private because it's "unsafe". It requires the window to be in unbound state
 private func getBindingDataForNewWindow(_ axWindow: AXUIElement, _ workspace: Workspace, _ app: MacApp) -> BindingData {
+    // Top priority: Always check for empty splits first, regardless of window type
+    // This ensures even dialog windows can be placed in empty splits if available
+    
+    // First, check if there's a focused empty split in the workspace
+    if let focusedEmptySplit = focus.emptySplitOrNil, 
+       focusedEmptySplit.mostRecentWorkspaceParent == workspace {
+        print("DEBUG: Using focused empty split for new window")
+        // Get the parent of the empty split
+        let parent = focusedEmptySplit.parent
+        let ownIndex = focusedEmptySplit.ownIndexOrNil ?? 0
+        
+        // Remove the empty split to replace it with the window
+        focusedEmptySplit.unbindFromParent()
+        
+        return BindingData(
+            parent: parent,
+            adaptiveWeight: WEIGHT_AUTO,
+            index: ownIndex
+        )
+    }
+    
+    // Second, check if there are any empty splits in the workspace
+    if let firstEmptySplit = workspace.firstEmptySplitRecursive {
+        print("DEBUG: Using available empty split for new window")
+        // Get the parent of the empty split
+        let parent = firstEmptySplit.parent
+        let ownIndex = firstEmptySplit.ownIndexOrNil ?? 0
+        
+        // Remove the empty split to replace it with the window
+        firstEmptySplit.unbindFromParent()
+        
+        return BindingData(
+            parent: parent,
+            adaptiveWeight: WEIGHT_AUTO,
+            index: ownIndex
+        )
+    }
+    
+    // If no empty splits are available, fall back to original logic
     if !isWindow(axWindow, app) {
         return BindingData(parent: macosPopupWindowsContainer, adaptiveWeight: WEIGHT_AUTO, index: INDEX_BIND_LAST)
     }
-- 
2.39.5 (Apple Git-154)

