From b76f19bb8c143704d09b2360330e459b953bce4e Mon Sep 17 00:00:00 2001
From: santhoshr <santhoshr@live.com>
Date: Fri, 28 Feb 2025 05:26:47 +0530
Subject: [PATCH] Super buggy workspace / split border impl

---
 Sources/AppBundle/FocusedWindowBorder.swift   | 199 +++++++++++++-----
 .../command/impl/EnableCommand.swift          |   2 +-
 Sources/AppBundle/focus.swift                 |  42 ++--
 Sources/AppBundle/model/Monitor.swift         |   6 +
 4 files changed, 185 insertions(+), 64 deletions(-)

diff --git a/Sources/AppBundle/FocusedWindowBorder.swift b/Sources/AppBundle/FocusedWindowBorder.swift
index 2b6e3e1..5ecd239 100644
--- a/Sources/AppBundle/FocusedWindowBorder.swift
+++ b/Sources/AppBundle/FocusedWindowBorder.swift
@@ -1,65 +1,164 @@
 import AppKit
 
+enum BorderType {
+    case workspace   // For overall workspace border
+    case activePane  // For currently focused window/pane
+    case inactivePane // For other windows/panes in the workspace
+    
+    var config: BorderConfig {
+        switch self {
+        case .workspace:
+            return BorderConfig(
+                color: NSColor(red: 1.0, green: 0.3, blue: 0.3, alpha: 0.8), // Red
+                width: 6.0,
+                level: Int(CGWindowLevelForKey(.mainMenuWindow)) + 2
+            )
+        case .activePane:
+            return BorderConfig(
+                color: NSColor(red: 0.2, green: 0.6, blue: 1.0, alpha: 0.8), // Blue
+                width: 4.0,
+                level: Int(CGWindowLevelForKey(.mainMenuWindow)) + 1
+            )
+        case .inactivePane:
+            return BorderConfig(
+                color: NSColor(red: 0.5, green: 0.5, blue: 0.5, alpha: 0.5), // Grey
+                width: 2.0,
+                level: Int(CGWindowLevelForKey(.mainMenuWindow))
+            )
+        }
+    }
+}
+
+struct BorderConfig {
+    let color: NSColor
+    let width: CGFloat
+    let level: Int
+}
+
+class BorderWindow {
+    private var window: NSWindow
+    private let type: BorderType
+    
+    init(frame: NSRect, type: BorderType) {
+        self.type = type
+        let config = type.config
+        let borderFrame = frame.insetBy(dx: -config.width, dy: -config.width)
+        
+        window = NSWindow(
+            contentRect: borderFrame,
+            styleMask: .borderless,
+            backing: .buffered,
+            defer: false
+        )
+        
+        window.isOpaque = false
+        window.backgroundColor = .clear
+        window.hasShadow = false
+        window.ignoresMouseEvents = true
+        window.isReleasedWhenClosed = false
+        window.collectionBehavior = [.canJoinAllSpaces, .stationary, .ignoresCycle]
+        window.level = NSWindow.Level(rawValue: config.level)
+        
+        let borderView = NSView(frame: NSRect(origin: .zero, size: borderFrame.size))
+        borderView.wantsLayer = true
+        borderView.layer?.backgroundColor = .clear
+        borderView.layer?.borderWidth = config.width
+        borderView.layer?.borderColor = config.color.cgColor
+        borderView.layer?.cornerRadius = 6.0
+        borderView.layer?.masksToBounds = true
+        
+        window.contentView = borderView
+        borderView.autoresizingMask = [.width, .height]
+    }
+    
+    func show() {
+        window.orderFront(nil)
+        animateBorder()
+    }
+    
+    func hide() {
+        window.orderOut(nil)
+    }
+    
+    func updateFrame(_ frame: NSRect) {
+        let config = type.config
+        let borderFrame = frame.insetBy(dx: -config.width, dy: -config.width)
+        window.setFrame(borderFrame, display: true)
+    }
+    
+    private func animateBorder() {
+        guard let layer = window.contentView?.layer else { return }
+        layer.removeAllAnimations()
+        
+        let animation = CABasicAnimation(keyPath: "borderColor")
+        animation.fromValue = type.config.color.withAlphaComponent(0.3).cgColor
+        animation.toValue = type.config.color.cgColor
+        animation.duration = 0.2
+        animation.timingFunction = CAMediaTimingFunction(name: .easeInEaseOut)
+        layer.add(animation, forKey: "borderFade")
+    }
+}
+
 class FocusedWindowBorder {
     static let shared = FocusedWindowBorder()
-    private var borderWindow: NSWindow?
-    private let borderWidth: CGFloat = 4.0
-    private let borderColor: NSColor = NSColor(red: 0.2, green: 0.6, blue: 1.0, alpha: 0.8)
     
-    func showBorder(frame: NSRect) {
-        let borderFrame = frame.insetBy(dx: -borderWidth, dy: -borderWidth)
+    private var workspaceBorder: BorderWindow?
+    private var activeBorder: BorderWindow?
+    private var inactiveBorders: [BorderWindow] = []
+    
+    func updateBorders(workspace: NSRect?, active: NSRect?, inactive: [NSRect]?) {
+        // Update workspace border
+        if let frame = workspace {
+            if let existing = workspaceBorder {
+                existing.updateFrame(frame)
+                existing.show()
+            } else {
+                workspaceBorder = BorderWindow(frame: frame, type: .workspace)
+                workspaceBorder?.show()
+            }
+        } else {
+            workspaceBorder?.hide()
+        }
         
-        if let existingWindow = borderWindow {
-            existingWindow.setFrame(borderFrame, display: true)
+        // Update active window border
+        if let frame = active {
+            if let existing = activeBorder {
+                existing.updateFrame(frame)
+                existing.show()
+            } else {
+                activeBorder = BorderWindow(frame: frame, type: .activePane)
+                activeBorder?.show()
+            }
         } else {
-            let window = NSWindow(
-                contentRect: borderFrame,
-                styleMask: .borderless,
-                backing: .buffered,
-                defer: false)
-            
-            // Make window completely transparent
-            window.isOpaque = false
-            window.backgroundColor = .clear
-            window.hasShadow = false
-            window.ignoresMouseEvents = true
-            window.isReleasedWhenClosed = false
-            window.collectionBehavior = [.canJoinAllSpaces, .stationary, .ignoresCycle]
-            window.level = NSWindow.Level(rawValue: Int(CGWindowLevelForKey(.mainMenuWindow)) + 1)
-            
-            // Use simple NSView instead of NSVisualEffectView for pure transparency
-            let borderView = NSView(frame: NSRect(origin: .zero, size: borderFrame.size))
-            borderView.wantsLayer = true
-            
-            // Configure border
-            borderView.layer?.backgroundColor = .clear
-            borderView.layer?.borderWidth = borderWidth
-            borderView.layer?.borderColor = borderColor.cgColor
-            borderView.layer?.cornerRadius = 6.0
-            borderView.layer?.masksToBounds = true
-            
-            window.contentView = borderView
-            borderView.autoresizingMask = [.width, .height]
-            
-            self.borderWindow = window
+            activeBorder?.hide()
         }
         
-        borderWindow?.orderFront(nil)
+        // Update inactive borders
+        updateInactiveBorders(frames: inactive ?? [])
+    }
+    
+    private func updateInactiveBorders(frames: [NSRect]) {
+        // Remove excess borders
+        while inactiveBorders.count > frames.count {
+            inactiveBorders.removeLast().hide()
+        }
         
-        // Gentle fade-in animation
-        if let layer = borderWindow?.contentView?.layer {
-            layer.removeAllAnimations()
-            
-            let animation = CABasicAnimation(keyPath: "borderColor")
-            animation.fromValue = borderColor.withAlphaComponent(0.3).cgColor
-            animation.toValue = borderColor.cgColor
-            animation.duration = 0.2
-            animation.timingFunction = CAMediaTimingFunction(name: .easeInEaseOut)
-            layer.add(animation, forKey: "borderFade")
+        // Update or create borders as needed
+        for (index, frame) in frames.enumerated() {
+            if index < inactiveBorders.count {
+                inactiveBorders[index].updateFrame(frame)
+                inactiveBorders[index].show()
+            } else {
+                let border = BorderWindow(frame: frame, type: .inactivePane)
+                inactiveBorders.append(border)
+                border.show()
+            }
         }
     }
     
-    func hideBorder() {
-        borderWindow?.orderOut(nil)
+    func hideAll() {
+        workspaceBorder?.hide()
+        activeBorder?.hide()
+        inactiveBorders.forEach { $0.hide() }
     }
 }
diff --git a/Sources/AppBundle/command/impl/EnableCommand.swift b/Sources/AppBundle/command/impl/EnableCommand.swift
index c6cac51..be240e7 100644
--- a/Sources/AppBundle/command/impl/EnableCommand.swift
+++ b/Sources/AppBundle/command/impl/EnableCommand.swift
@@ -39,7 +39,7 @@ struct EnableCommand: Command, Equatable {
                 workspace.allLeafWindowsRecursive.forEach { ($0 as! MacWindow).unhideFromCorner() } // todo as!
                 workspace.layoutWorkspace() // Unhide tiling windows from corner
             }
-            focusedWindowBorder.hideBorder()
+            focusedWindowBorder.hideAll() // Use hideAll instead of hideBorder
         }
     return true
 }
diff --git a/Sources/AppBundle/focus.swift b/Sources/AppBundle/focus.swift
index 6bfb71b..d34ed43 100644
--- a/Sources/AppBundle/focus.swift
+++ b/Sources/AppBundle/focus.swift
@@ -216,21 +216,37 @@ private func onFocusedMonitorChanged(_ focus: LiveFocus) {
 }
 
 private func updateFocusBorder(oldFocus: LiveFocus, newFocus: LiveFocus) {
-    if let window = newFocus.windowOrNil {
-        if let topLeft = window.getTopLeftCorner(), 
-           let size = window.getSize() {
-            let focusedFrame = NSRect(x: topLeft.x, y: topLeft.y, 
-                                    width: size.width, height: size.height)
-            FocusedWindowBorder.shared.showBorder(frame: focusedFrame)
-        }
-    } else if let emptySplit = newFocus.emptySplitOrNil, 
+    // Get workspace frame
+    let workspaceFrame = newFocus.workspace.workspaceMonitor.visibleRect.nsRect
+    
+    // Get active window/split frame
+    var activeFrame: NSRect? = nil
+    if let window = newFocus.windowOrNil,
+       let topLeft = window.getTopLeftCorner(),
+       let size = window.getSize() {
+        activeFrame = NSRect(x: topLeft.x, y: topLeft.y, width: size.width, height: size.height)
+    } else if let emptySplit = newFocus.emptySplitOrNil,
               let rect = emptySplit.getFrameForRendering() {
-        let focusedFrame = NSRect(x: rect.topLeftX, y: rect.topLeftY, 
-                                width: rect.width, height: rect.height)
-        FocusedWindowBorder.shared.showBorder(frame: focusedFrame)
-    } else {
-        FocusedWindowBorder.shared.hideBorder()
+        activeFrame = rect.nsRect
     }
+    
+    // Get inactive window frames - Remove optional binding since workspace is non-optional
+    var inactiveFrames: [NSRect] = []
+    let workspace = newFocus.workspace
+    inactiveFrames = workspace.rootTilingContainer.allLeafWindowsRecursive
+        .filter { $0 != newFocus.windowOrNil }
+        .compactMap { window in
+            guard let topLeft = window.getTopLeftCorner(),
+                  let size = window.getSize() else { return nil }
+            return NSRect(x: topLeft.x, y: topLeft.y, width: size.width, height: size.height)
+        }
+    
+    // Update all borders
+    FocusedWindowBorder.shared.updateBorders(
+        workspace: workspaceFrame,
+        active: activeFrame,
+        inactive: inactiveFrames
+    )
 }
 
 private func onFocusChanged(_ focus: LiveFocus) {
diff --git a/Sources/AppBundle/model/Monitor.swift b/Sources/AppBundle/model/Monitor.swift
index 482c956..0c992b3 100644
--- a/Sources/AppBundle/model/Monitor.swift
+++ b/Sources/AppBundle/model/Monitor.swift
@@ -24,6 +24,12 @@ protocol Monitor: AeroAny {
     var height: CGFloat { get }
 }
 
+extension Monitor {
+    var visibleFrame: NSRect {
+        return visibleRect.nsRect
+    }
+}
+
 class LazyMonitor: Monitor {
     private let screen: NSScreen
     let monitorAppKitNsScreenScreensId: Int
-- 
2.39.5 (Apple Git-154)

