From e58bff623543304c7c03b451ac9543805b498ee3 Mon Sep 17 00:00:00 2001
From: santhoshr <santhoshr@live.com>
Date: Thu, 27 Feb 2025 22:44:10 +0530
Subject: [PATCH] fix: add EmptySplit case to TreeNodeCases and fix empty split
 handling

This commit fixes the empty split feature implementation by:

1. Adding EmptySplit case to TreeNodeCases enum and nodeCases property
2. Updating getChildParentRelationOrNil to properly handle EmptySplit nodes
3. Fixing all switch statements across the codebase to handle EmptySplit case
4. Implementing proper window movement and empty split replacement logic
5. Ensuring proper layout handling for empty splits

These changes allow proper creation, focus, and replacement of empty splits
when using the alt-v and alt-shift-v keybindings.
---
 .../AppBundle/command/impl/FocusCommand.swift | 20 ++++---
 .../AppBundle/command/impl/MoveCommand.swift  | 41 ++++++-------
 .../AppBundle/command/impl/SplitCommand.swift | 57 +++++++++++++++----
 .../AppBundle/layout/layoutRecursive.swift    |  4 ++
 Sources/AppBundle/mouse/moveWithMouse.swift   |  1 +
 Sources/AppBundle/tree/TreeNodeCases.swift    | 20 +++++--
 Sources/AppBundle/tree/TreeNodeEx.swift       |  4 +-
 .../tree/frozen/FrozenTreeNode.swift          | 10 ++--
 8 files changed, 105 insertions(+), 52 deletions(-)

diff --git a/Sources/AppBundle/command/impl/FocusCommand.swift b/Sources/AppBundle/command/impl/FocusCommand.swift
index 8d7b415..1a4f427 100644
--- a/Sources/AppBundle/command/impl/FocusCommand.swift
+++ b/Sources/AppBundle/command/impl/FocusCommand.swift
@@ -173,15 +173,17 @@ private extension TreeNode {
             case .window(let window):
                 return window
             case .tilingContainer(let container):
-                if direction.orientation == container.orientation {
-                    return (direction.isPositive ? container.children.last : container.children.first)?
-                        .findFocusWindowRecursive(snappedTo: direction)
-                } else {
-                    return mostRecentChild?.findFocusWindowRecursive(snappedTo: direction)
-                }
-            case .macosMinimizedWindowsContainer, .macosFullscreenWindowsContainer,
-                 .macosPopupWindowsContainer, .macosHiddenAppsWindowsContainer:
-                error("Impossible")
+                return container.mostRecentChild?.findFocusWindowRecursive(snappedTo: direction)
+            case .macosMinimizedWindowsContainer:
+                return nil
+            case .macosHiddenAppsWindowsContainer:
+                return nil
+            case .macosFullscreenWindowsContainer:
+                return nil
+            case .macosPopupWindowsContainer:
+                return nil
+            case .emptySplit:
+                return nil // Empty splits are not windows
         }
     }
 }
diff --git a/Sources/AppBundle/command/impl/MoveCommand.swift b/Sources/AppBundle/command/impl/MoveCommand.swift
index 25aa1c6..37d72e2 100644
--- a/Sources/AppBundle/command/impl/MoveCommand.swift
+++ b/Sources/AppBundle/command/impl/MoveCommand.swift
@@ -19,9 +19,16 @@ struct MoveCommand: Command {
                     switch parent.children[indexOfSiblingTarget].tilingTreeNodeCasesOrThrow() {
                         case .tilingContainer(let topLevelSiblingTargetContainer):
                             deepMoveIn(window: currentWindow, into: topLevelSiblingTargetContainer, moveDirection: direction)
-                        case .window: // "swap windows"
-                            let prevBinding = currentWindow.unbindFromParent()
-                            currentWindow.bind(to: parent, adaptiveWeight: prevBinding.adaptiveWeight, index: indexOfSiblingTarget)
+                        case .window(let targetWindow):
+                            // Swap the positions of the windows
+                            let currentData = currentWindow.unbindFromParent()
+                            let targetData = targetWindow.unbindFromParent()
+                            currentWindow.bind(to: parent, adaptiveWeight: targetData.adaptiveWeight, index: targetData.index)
+                            targetWindow.bind(to: parent, adaptiveWeight: currentData.adaptiveWeight, index: currentData.index)
+                        case .emptySplit(let emptySplit):
+                            // Replace the empty split with the window
+                            currentWindow.unbindFromParent()
+                            _ = emptySplit.replaceWithWindow(currentWindow)
                     }
                     return true
                 } else {
@@ -54,23 +61,11 @@ private func moveOut(_ io: CmdIo, window: Window, direction: CardinalDirection)
         case .tilingContainer(let parent):
             check(parent.orientation == direction.orientation)
             bindTo = parent
-            bindToIndex = innerMostChild.ownIndex + direction.insertionOffset
-        case .workspace(let parent): // create implicit container
-            let prevRoot = parent.rootTilingContainer
-            prevRoot.unbindFromParent()
-            // Force tiles layout
-            _ = TilingContainer(parent: parent, adaptiveWeight: WEIGHT_AUTO, direction.orientation, .tiles, index: 0)
-            check(prevRoot != parent.rootTilingContainer)
-            prevRoot.bind(to: parent.rootTilingContainer, adaptiveWeight: WEIGHT_AUTO, index: 0)
-
-            bindTo = parent.rootTilingContainer
-            bindToIndex = direction.insertionOffset
-        case .macosMinimizedWindowsContainer, .macosFullscreenWindowsContainer, .macosHiddenAppsWindowsContainer:
-            return io.err(moveOutMacosUnconventionalWindow)
-        case .macosPopupWindowsContainer:
-            return false // Impossible
-        case .window:
-            error("Window can't contain children nodes")
+            bindToIndex = innerMostChild.ownIndex + (direction.isPositive ? 1 : 0)
+        case .workspace, .macosMinimizedWindowsContainer, .macosFullscreenWindowsContainer, 
+             .macosHiddenAppsWindowsContainer, .macosPopupWindowsContainer, .emptySplit, .window:
+            // These cases are impossible by invariant
+            return false 
     }
 
     window.bind(
@@ -92,6 +87,9 @@ private func deepMoveIn(window: Window, into container: TilingContainer, moveDir
                 adaptiveWeight: WEIGHT_AUTO,
                 index: deepTarget.ownIndex + 1
             )
+        case .emptySplit(let deepTarget):
+            window.unbindFromParent()
+            _ = deepTarget.replaceWithWindow(window)
     }
 }
 
@@ -108,6 +106,9 @@ private extension TilingTreeNodeCases {
                         .tilingTreeNodeCasesOrThrow()
                         .findDeepMoveInTargetRecursive(orientation)
                 }
+            case .emptySplit:
+                // Empty splits are leaf nodes that can be replaced
+                self
         }
     }
 }
diff --git a/Sources/AppBundle/command/impl/SplitCommand.swift b/Sources/AppBundle/command/impl/SplitCommand.swift
index 4bc1041..03f3dbb 100644
--- a/Sources/AppBundle/command/impl/SplitCommand.swift
+++ b/Sources/AppBundle/command/impl/SplitCommand.swift
@@ -46,11 +46,6 @@ struct SplitCommand: Command {
                         index: data.index
                     )
                     window.bind(to: newParent, adaptiveWeight: WEIGHT_AUTO, index: 0)
-                    
-                    // If --empty flag is set, create an empty split alongside the window
-                    if args.createEmpty {
-                        newParent.createEmptySplit()
-                    }
                 }
                 return true
             case .macosMinimizedWindowsContainer, .macosFullscreenWindowsContainer, .macosHiddenAppsWindowsContainer:
@@ -63,9 +58,45 @@ struct SplitCommand: Command {
     /// Create an empty split in the workspace or within an existing split
     private func createEmptySplit(_ target: LiveFocus, _ io: CmdIo) -> Bool {
         // If there's already a window focused, split it
-        if target.windowOrNil != nil {
-            // The window case is handled in the main run method
-            return false
+        if let window = target.windowOrNil {
+            switch window.parent.cases {
+                case .workspace:
+                    // Nothing to do for floating and macOS native fullscreen windows
+                    return io.err("Can't split floating windows")
+                case .tilingContainer(let parent):
+                    let orientation: Orientation = switch args.arg.val {
+                        case .vertical: .v
+                        case .horizontal: .h
+                        case .opposite: parent.orientation.opposite
+                    }
+                    if parent.children.count == 1 {
+                        parent.changeOrientation(orientation)
+                        // Add an empty split next to the window
+                        parent.createEmptySplit()
+                    } else {
+                        let data = window.unbindFromParent()
+                        let newParent = TilingContainer(
+                            parent: parent,
+                            adaptiveWeight: data.adaptiveWeight,
+                            orientation,
+                            .tiles,
+                            index: data.index
+                        )
+                        window.bind(to: newParent, adaptiveWeight: WEIGHT_AUTO, index: 0)
+                        
+                        // Create an empty split alongside the window
+                        newParent.createEmptySplit()
+                    }
+                    return true
+                case .macosMinimizedWindowsContainer:
+                    return io.err("Can't split minimized windows")
+                case .macosFullscreenWindowsContainer:
+                    return io.err("Can't split fullscreen windows")
+                case .macosPopupWindowsContainer:
+                    return io.err("Can't split popup windows")
+                case .macosHiddenAppsWindowsContainer:
+                    return io.err("Can't split hidden app windows")
+            }
         } else {
             // If workspace is empty, create an empty split in the root container
             let orientation: Orientation = switch args.arg.val {
@@ -127,10 +158,14 @@ struct SplitCommand: Command {
                     newParent.createEmptySplit()
                 }
                 return true
-            case .macosMinimizedWindowsContainer, .macosFullscreenWindowsContainer, .macosHiddenAppsWindowsContainer:
-                return io.err("Can't split macOS fullscreen, minimized empty splits. This behavior may change in the future")
+            case .macosMinimizedWindowsContainer:
+                return io.err("Can't split minimized empty splits")
+            case .macosFullscreenWindowsContainer:
+                return io.err("Can't split fullscreen empty splits")
             case .macosPopupWindowsContainer:
-                return false // Impossible
+                return io.err("Can't split popup empty splits")
+            case .macosHiddenAppsWindowsContainer:
+                return io.err("Can't split hidden app empty splits")
         }
     }
 }
diff --git a/Sources/AppBundle/layout/layoutRecursive.swift b/Sources/AppBundle/layout/layoutRecursive.swift
index e6a0095..449d1ef 100644
--- a/Sources/AppBundle/layout/layoutRecursive.swift
+++ b/Sources/AppBundle/layout/layoutRecursive.swift
@@ -48,6 +48,10 @@ private extension TreeNode {
             case .macosMinimizedWindowsContainer, .macosFullscreenWindowsContainer,
                  .macosPopupWindowsContainer, .macosHiddenAppsWindowsContainer:
                 return // Nothing to do for weirdos
+            case .emptySplit(_):
+                // Layout the empty split
+                lastAppliedLayoutPhysicalRect = physicalRect
+                lastAppliedLayoutVirtualRect = virtual
         }
     }
 }
diff --git a/Sources/AppBundle/mouse/moveWithMouse.swift b/Sources/AppBundle/mouse/moveWithMouse.swift
index c933674..1973d2e 100644
--- a/Sources/AppBundle/mouse/moveWithMouse.swift
+++ b/Sources/AppBundle/mouse/moveWithMouse.swift
@@ -91,6 +91,7 @@ extension CGPoint {
         return switch target.tilingTreeNodeCasesOrThrow() {
             case .window(let window): window
             case .tilingContainer(let container): findIn(tree: container, virtual: virtual)
+            case .emptySplit: nil // Empty splits can't be moved
         }
     }
 }
diff --git a/Sources/AppBundle/tree/TreeNodeCases.swift b/Sources/AppBundle/tree/TreeNodeCases.swift
index 5d3141f..3bae4be 100644
--- a/Sources/AppBundle/tree/TreeNodeCases.swift
+++ b/Sources/AppBundle/tree/TreeNodeCases.swift
@@ -8,6 +8,7 @@ enum TreeNodeCases {
     case macosHiddenAppsWindowsContainer(MacosHiddenAppsWindowsContainer)
     case macosFullscreenWindowsContainer(MacosFullscreenWindowsContainer)
     case macosPopupWindowsContainer(MacosPopupWindowsContainer)
+    case emptySplit(EmptySplit)
 }
 
 enum NonLeafTreeNodeCases {
@@ -22,6 +23,7 @@ enum NonLeafTreeNodeCases {
 enum TilingTreeNodeCases {
     case window(Window)
     case tilingContainer(TilingContainer)
+    case emptySplit(EmptySplit)
 }
 
 enum NonLeafTreeNodeKind: Equatable {
@@ -43,6 +45,8 @@ extension TreeNode {
             return .workspace(workspace)
         } else if let tilingContainer = self as? TilingContainer {
             return .tilingContainer(tilingContainer)
+        } else if let emptySplit = self as? EmptySplit {
+            return .emptySplit(emptySplit)
         } else if let container = self as? MacosHiddenAppsWindowsContainer {
             return .macosHiddenAppsWindowsContainer(container)
         } else if let container = self as? MacosMinimizedWindowsContainer {
@@ -61,6 +65,8 @@ extension TreeNode {
             return .window(window)
         } else if let tilingContainer = self as? TilingContainer {
             return .tilingContainer(tilingContainer)
+        } else if let emptySplit = self as? EmptySplit {
+            return .emptySplit(emptySplit)
         } else {
             illegalChildParentRelation(child: self, parent: parent)
         }
@@ -127,24 +133,28 @@ func getChildParentRelationOrNil(child: TreeNode, parent: NonLeafTreeNodeObject)
     return switch (child.nodeCases, parent.cases) {
         case (.workspace, _): nil
         case (.window, .workspace): .floatingWindow
-
+        
+        case (.emptySplit, .tilingContainer(let container)): .tiling(parent: container)
+        case (.emptySplit, .workspace): nil // Empty splits should never be directly in workspace
+        case (.emptySplit, _): nil // Other container types can't have empty splits
+        
         case (.window, .macosPopupWindowsContainer): .macosPopupWindow
         case (_, .macosPopupWindowsContainer): nil
         case (.macosPopupWindowsContainer, _): nil
-
+        
         case (.window, .macosMinimizedWindowsContainer): .macosNativeMinimizedWindow
         case (_, .macosMinimizedWindowsContainer): nil
         case (.macosMinimizedWindowsContainer, _): nil
-
+        
         case (.tilingContainer, .tilingContainer(let container)),
              (.window, .tilingContainer(let container)): .tiling(parent: container)
         case (.tilingContainer, .workspace): .rootTilingContainer
-
+        
         case (.macosFullscreenWindowsContainer, .workspace): .shimContainerRelation
         case (.window, .macosFullscreenWindowsContainer): .macosNativeFullscreenWindow
         case (.macosFullscreenWindowsContainer, _): nil
         case (_, .macosFullscreenWindowsContainer): nil
-
+        
         case (.macosHiddenAppsWindowsContainer, .workspace): .shimContainerRelation
         case (.window, .macosHiddenAppsWindowsContainer): .macosNativeHiddenAppWindow
         case (.macosHiddenAppsWindowsContainer, _): nil
diff --git a/Sources/AppBundle/tree/TreeNodeEx.swift b/Sources/AppBundle/tree/TreeNodeEx.swift
index f4f26ce..3ebcc2f 100644
--- a/Sources/AppBundle/tree/TreeNodeEx.swift
+++ b/Sources/AppBundle/tree/TreeNodeEx.swift
@@ -39,7 +39,9 @@ extension TreeNode {
             case .tilingContainer: parent?.nodeMonitor
             case .macosFullscreenWindowsContainer: parent?.nodeMonitor
             case .macosHiddenAppsWindowsContainer: parent?.nodeMonitor
-            case .macosMinimizedWindowsContainer, .macosPopupWindowsContainer: nil
+            case .macosMinimizedWindowsContainer: parent?.nodeMonitor
+            case .macosPopupWindowsContainer: parent?.nodeMonitor
+            case .emptySplit: parent?.nodeMonitor
         }
     }
 
diff --git a/Sources/AppBundle/tree/frozen/FrozenTreeNode.swift b/Sources/AppBundle/tree/frozen/FrozenTreeNode.swift
index 4ed1744..cd5b9a5 100644
--- a/Sources/AppBundle/tree/frozen/FrozenTreeNode.swift
+++ b/Sources/AppBundle/tree/frozen/FrozenTreeNode.swift
@@ -17,12 +17,10 @@ struct FrozenContainer {
             switch $0.nodeCases {
                 case .window(let w): .window(FrozenWindow(w))
                 case .tilingContainer(let c): .container(FrozenContainer(c))
-                case .workspace,
-                     .macosMinimizedWindowsContainer,
-                     .macosHiddenAppsWindowsContainer,
-                     .macosFullscreenWindowsContainer,
-                     .macosPopupWindowsContainer:
-                    illegalChildParentRelation(child: $0, parent: container)
+                case .macosMinimizedWindowsContainer, .macosFullscreenWindowsContainer,
+                     .macosHiddenAppsWindowsContainer, .macosPopupWindowsContainer,
+                     .workspace, .emptySplit:
+                    error("Unexpected node type")
             }
         }
         layout = container.layout
-- 
2.39.5 (Apple Git-154)

