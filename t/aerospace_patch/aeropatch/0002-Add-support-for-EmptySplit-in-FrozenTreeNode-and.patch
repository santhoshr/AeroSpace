From 6e9cb01c3678ee584b57b903fde3cf175604927c Mon Sep 17 00:00:00 2001
From: santhoshr <santhoshr@live.com>
Date: Thu, 27 Feb 2025 23:30:38 +0530
Subject: [PATCH] Add support for EmptySplit in FrozenTreeNode and implement
 initial border rendering framework

---
 Sources/AppBundle/focus.swift                 |  12 ++
 Sources/AppBundle/tree/EmptySplit.swift       |  13 +++
 Sources/AppBundle/tree/EmptySplitVisual.swift | 104 ++++++++++++++++++
 .../tree/frozen/FrozenTreeNode.swift          |  14 ++-
 .../AppBundle/tree/frozen/FrozenWorld.swift   |   1 +
 .../tree/frozen/closedWindowsCache.swift      |   4 +
 .../command/MoveCommandTest.swift             |   2 +
 7 files changed, 149 insertions(+), 1 deletion(-)
 create mode 100644 Sources/AppBundle/tree/EmptySplitVisual.swift

diff --git a/Sources/AppBundle/focus.swift b/Sources/AppBundle/focus.swift
index 22eeef7..4c3a154 100644
--- a/Sources/AppBundle/focus.swift
+++ b/Sources/AppBundle/focus.swift
@@ -1,4 +1,5 @@
 import AppKit
+import Foundation
 import Common
 
 enum EffectiveLeaf {
@@ -44,6 +45,10 @@ struct LiveFocus: AeroAny, Equatable {
     var hasLeafFocus: Bool {
         return windowOrNil != nil || emptySplitOrNil != nil
     }
+    
+    func updateEmptySplitVisual() {
+        emptySplitOrNil?.updateVisual()
+    }
 }
 
 /// "old", "captured", "frozen in time" Focus
@@ -94,11 +99,18 @@ func setFocus(to newFocus: LiveFocus) -> Bool {
     if oldFocus.workspace != newFocus.workspace {
         oldFocus.windowOrNil?.markAsMostRecentChild()
     }
+    
+    // Hide old empty split borders
+    if let oldEmptySplit = oldFocus.emptySplitOrNil, 
+       let visual = emptySplitVisuals[oldEmptySplit.id] {
+        visual.hideBorder()
+    }
 
     _focus = newFocus.frozen
     let status = newFocus.workspace.workspaceMonitor.setActiveWorkspace(newFocus.workspace)
 
     newFocus.windowOrNil?.markAsMostRecentChild()
+    newFocus.updateEmptySplitVisual()
     return status
 }
 extension Window {
diff --git a/Sources/AppBundle/tree/EmptySplit.swift b/Sources/AppBundle/tree/EmptySplit.swift
index 4bf4c33..85c4865 100644
--- a/Sources/AppBundle/tree/EmptySplit.swift
+++ b/Sources/AppBundle/tree/EmptySplit.swift
@@ -44,6 +44,19 @@ class EmptySplit: TreeNode {
         return LiveFocus(windowOrNil: nil, emptySplitOrNil: self, workspace: mostRecentWorkspaceParent)
     }
     
+    /// Update the visual representation of this empty split
+    func updateVisual() {
+        // Get the visual for this empty split
+        let visual = emptySplitVisuals[id] ?? {
+            let newVisual = EmptySplitVisual(emptySplit: self)
+            emptySplitVisuals[id] = newVisual
+            return newVisual
+        }()
+        
+        // Show the border
+        visual.showBorder()
+    }
+    
     /// Get the containing workspace
     var mostRecentWorkspaceParent: Workspace {
         let fullParentChain = parentsWithSelf
diff --git a/Sources/AppBundle/tree/EmptySplitVisual.swift b/Sources/AppBundle/tree/EmptySplitVisual.swift
new file mode 100644
index 0000000..1912f9d
--- /dev/null
+++ b/Sources/AppBundle/tree/EmptySplitVisual.swift
@@ -0,0 +1,104 @@
+import AppKit
+import Common
+
+/// A class that handles the visual representation of an empty split
+class EmptySplitVisual {
+    /// The empty split this visual represents
+    private let emptySplit: EmptySplit
+    
+    /// The window used to render the border
+    private var borderWindow: NSWindow?
+    
+    /// Border color for focused empty split
+    private let focusedBorderColor = NSColor(red: 0.0, green: 0.5, blue: 1.0, alpha: 0.8)
+    
+    /// Border width
+    private let borderWidth: CGFloat = 2.0
+    
+    /// Initialize with an empty split
+    init(emptySplit: EmptySplit) {
+        self.emptySplit = emptySplit
+    }
+    
+    /// Show the border around the empty split
+    func showBorder() {
+        // Remove existing border if any
+        hideBorder()
+        
+        // Get the frame for rendering
+        guard let frame = emptySplit.getFrameForRendering() else { return }
+        
+        // Convert to CGRect
+        let rect = CGRect(
+            x: frame.topLeftX,
+            y: frame.topLeftY,
+            width: frame.width,
+            height: frame.height
+        )
+        
+        // Create a borderless window to show the border
+        let borderWindow = NSWindow(
+            contentRect: rect,
+            styleMask: [.borderless],
+            backing: .buffered,
+            defer: false
+        )
+        
+        // Configure the window
+        borderWindow.level = NSWindow.Level.floating
+        borderWindow.backgroundColor = NSColor.clear
+        borderWindow.isOpaque = false
+        borderWindow.hasShadow = false
+        borderWindow.ignoresMouseEvents = true
+        
+        // Create a view for the border
+        let borderView = BorderView(frame: NSRect(x: 0, y: 0, width: rect.width, height: rect.height))
+        borderView.borderColor = focusedBorderColor
+        borderView.borderWidth = borderWidth
+        
+        // Set the view
+        borderWindow.contentView = borderView
+        
+        // Store the window and show it
+        self.borderWindow = borderWindow
+        borderWindow.orderFront(nil as Any?)
+    }
+    
+    /// Hide the border
+    func hideBorder() {
+        borderWindow?.close()
+        borderWindow = nil
+    }
+}
+
+/// A view that draws a border
+class BorderView: NSView {
+    /// The color of the border
+    var borderColor: NSColor = .blue
+    
+    /// The width of the border
+    var borderWidth: CGFloat = 2.0
+    
+    override func draw(_ dirtyRect: NSRect) {
+        super.draw(dirtyRect)
+        
+        // Clear the background
+        NSColor.clear.set()
+        dirtyRect.fill()
+        
+        // Draw the border
+        borderColor.set()
+        
+        let borderPath = NSBezierPath(rect: NSRect(
+            x: borderWidth / 2,
+            y: borderWidth / 2,
+            width: bounds.width - borderWidth,
+            height: bounds.height - borderWidth
+        ))
+        borderPath.lineWidth = borderWidth
+        borderPath.stroke()
+    }
+}
+
+/// Global storage for empty split visuals
+var emptySplitVisuals: [UUID: EmptySplitVisual] = [:]
diff --git a/Sources/AppBundle/tree/frozen/FrozenTreeNode.swift b/Sources/AppBundle/tree/frozen/FrozenTreeNode.swift
index cd5b9a5..b209148 100644
--- a/Sources/AppBundle/tree/frozen/FrozenTreeNode.swift
+++ b/Sources/AppBundle/tree/frozen/FrozenTreeNode.swift
@@ -4,6 +4,7 @@ import Common
 enum FrozenTreeNode {
     case container(FrozenContainer)
     case window(FrozenWindow)
+    case emptySplit(FrozenEmptySplit)
 }
 
 struct FrozenContainer {
@@ -17,9 +18,10 @@ struct FrozenContainer {
             switch $0.nodeCases {
                 case .window(let w): .window(FrozenWindow(w))
                 case .tilingContainer(let c): .container(FrozenContainer(c))
+                case .emptySplit(let e): .emptySplit(FrozenEmptySplit(e))
                 case .macosMinimizedWindowsContainer, .macosFullscreenWindowsContainer,
                      .macosHiddenAppsWindowsContainer, .macosPopupWindowsContainer,
-                     .workspace, .emptySplit:
+                     .workspace:
                     error("Unexpected node type")
             }
         }
@@ -39,6 +41,16 @@ struct FrozenWindow {
     }
 }
 
+struct FrozenEmptySplit {
+    let uuid: UUID
+    let weight: CGFloat
+    
+    init(_ emptySplit: EmptySplit) {
+        self.uuid = emptySplit.id
+        self.weight = getWeightOrNil(emptySplit) ?? 1
+    }
+}
+
 private func getWeightOrNil(_ node: TreeNode) -> CGFloat? {
     ((node.parent as? TilingContainer)?.orientation).map { node.getWeight($0) }
 }
diff --git a/Sources/AppBundle/tree/frozen/FrozenWorld.swift b/Sources/AppBundle/tree/frozen/FrozenWorld.swift
index 3a7b177..458d85f 100644
--- a/Sources/AppBundle/tree/frozen/FrozenWorld.swift
+++ b/Sources/AppBundle/tree/frozen/FrozenWorld.swift
@@ -19,6 +19,7 @@ private func collectAllWindowIds(workspace: FrozenWorkspace) -> [UInt32] {
 private func collectAllWindowIdsRecursive(node: FrozenTreeNode) -> [UInt32] {
     switch node {
         case .window(let w): [w.id]
+        case .emptySplit: [] 
         case .container(let c):
             c.children.reduce(into: [UInt32]()) { partialResult, elem in
                 partialResult += collectAllWindowIdsRecursive(node: elem)
diff --git a/Sources/AppBundle/tree/frozen/closedWindowsCache.swift b/Sources/AppBundle/tree/frozen/closedWindowsCache.swift
index 20da4b1..541f04b 100644
--- a/Sources/AppBundle/tree/frozen/closedWindowsCache.swift
+++ b/Sources/AppBundle/tree/frozen/closedWindowsCache.swift
@@ -102,6 +102,10 @@ private func restoreTreeRecursive(frozenContainer: FrozenContainer, parent: NonL
             case .container(let c):
                 // There is no reason to continue
                 if !restoreTreeRecursive(frozenContainer: c, parent: container, index: index) { return false }
+            case .emptySplit(let e):
+                // Create a new empty split in place of the frozen one
+                let emptySplit = EmptySplit(parent: container, adaptiveWeight: e.weight, index: index)
+                emptySplit.markAsMostRecentChild()
         }
     }
     return true
diff --git a/Sources/AppBundleTests/command/MoveCommandTest.swift b/Sources/AppBundleTests/command/MoveCommandTest.swift
index bf79ae6..7c016f9 100644
--- a/Sources/AppBundleTests/command/MoveCommandTest.swift
+++ b/Sources/AppBundleTests/command/MoveCommandTest.swift
@@ -195,6 +195,7 @@ extension TreeNode {
             case .macosFullscreenWindowsContainer: .macosFullscreen
             case .macosHiddenAppsWindowsContainer: .macosHiddeAppWindow
             case .macosPopupWindowsContainer: .macosPopupWindowsContainer
+            case .emptySplit: .emptySplit
             case .tilingContainer(let container):
                 switch container.layout {
                     case .tiles:
@@ -221,4 +222,5 @@ enum LayoutDescription: Equatable {
     case macosMinimized
     case macosHiddeAppWindow
     case macosFullscreen
+    case emptySplit
 }
-- 
2.39.5 (Apple Git-154)

