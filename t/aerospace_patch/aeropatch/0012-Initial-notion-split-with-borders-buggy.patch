From 1fdeb31f2ea195faf324dc699ee7929fca4fa3f1 Mon Sep 17 00:00:00 2001
From: santhoshr <santhoshr@live.com>
Date: Sun, 2 Mar 2025 17:17:15 +0530
Subject: [PATCH] Initial notion split with borders buggy

---
 Sources/AppBundle/command/cmdManifest.swift   |  2 +
 .../command/impl/NotionSplitCommand.swift     | 68 +++++++++++++++++
 Sources/AppBundle/util/BorderOverlay.swift    | 74 +++++++++++++++++++
 Sources/Common/cmdArgs/cmdArgsManifest.swift  |  3 +
 .../cmdArgs/impl/NotionSplitCmdArgs.swift     | 36 +++++++++
 current diff changes from repo                |  1 +
 6 files changed, 184 insertions(+)
 create mode 100644 Sources/AppBundle/command/impl/NotionSplitCommand.swift
 create mode 100644 Sources/AppBundle/util/BorderOverlay.swift
 create mode 100644 Sources/Common/cmdArgs/impl/NotionSplitCmdArgs.swift
 create mode 100644 current diff changes from repo

diff --git a/Sources/AppBundle/command/cmdManifest.swift b/Sources/AppBundle/command/cmdManifest.swift
index 70e38e0..7be1fb5 100644
--- a/Sources/AppBundle/command/cmdManifest.swift
+++ b/Sources/AppBundle/command/cmdManifest.swift
@@ -78,6 +78,8 @@ extension CmdArgs {
                 command = WorkspaceCommand(args: self as! WorkspaceCmdArgs)
             case .workspaceBackAndForth:
                 command = WorkspaceBackAndForthCommand(args: self as! WorkspaceBackAndForthCmdArgs)
+            case .notionSplit:
+                command = NotionSplitCommand(args: self as! NotionSplitCmdArgs)
         }
         check(command.info == Self.info)
         return command
diff --git a/Sources/AppBundle/command/impl/NotionSplitCommand.swift b/Sources/AppBundle/command/impl/NotionSplitCommand.swift
new file mode 100644
index 0000000..858b76b
--- /dev/null
+++ b/Sources/AppBundle/command/impl/NotionSplitCommand.swift
@@ -0,0 +1,68 @@
+import AppKit
+import Common
+
+struct NotionSplitCommand: Command {
+    let args: NotionSplitCmdArgs
+
+    func run(_ env: CmdEnv, _ io: CmdIo) -> Bool {
+        check(Thread.current.isMainThread)
+        
+        // Get the current workspace
+        guard let workspace = args.resolveTargetOrReportError(env, io)?.workspace else {
+            return io.err("No workspace is focused")
+        }
+        
+        // Clear any existing borders
+        clearAllBorders()
+        
+        // Get the orientation from the arguments
+        let orientation: Orientation = switch args.arg.val {
+            case .vertical: .v
+            case .horizontal: .h
+        }
+        
+        // Get the root tiling container
+        let rootContainer = workspace.rootTilingContainer
+        
+        // Create a new container with the specified orientation
+        rootContainer.changeOrientation(orientation)
+        
+        // Move all existing windows to the first container
+        let firstContainer = TilingContainer(
+            parent: rootContainer,
+            adaptiveWeight: WEIGHT_AUTO,
+            orientation.opposite,
+            .tiles,
+            index: 0
+        )
+        
+        // Move all windows from root to first container
+        let windowsToMove = rootContainer.children.filterIsInstance(of: Window.self)
+        for window in windowsToMove {
+            let data = window.unbindFromParent()
+            window.bind(to: firstContainer, adaptiveWeight: data.adaptiveWeight, index: INDEX_BIND_LAST)
+        }
+        
+        // Create a new empty container for the right/bottom half
+        let newContainer = TilingContainer(
+            parent: rootContainer,
+            adaptiveWeight: WEIGHT_AUTO,
+            orientation.opposite,
+            .tiles,
+            index: INDEX_BIND_LAST
+        )
+        
+        // Focus the new container
+        newContainer.markAsMostRecentChild()
+        
+        // Refresh the layout
+        workspace.layoutWorkspace()
+        
+        if let rect = newContainer.lastAppliedLayoutPhysicalRect {
+            // Use our custom border implementation instead of JankyBorders
+            createBorder(for: rect, color: NSColor.orange, thickness: 5.0)
+        }
+        
+        return true
+    }
+} 
\ No newline at end of file
diff --git a/Sources/AppBundle/util/BorderOverlay.swift b/Sources/AppBundle/util/BorderOverlay.swift
new file mode 100644
index 0000000..04b4dee
--- /dev/null
+++ b/Sources/AppBundle/util/BorderOverlay.swift
@@ -0,0 +1,74 @@
+import AppKit
+import Common
+
+// A singleton class to manage border overlays
+class BorderManager {
+    static let shared = BorderManager()
+    
+    private var borderWindows: [NSWindow] = []
+    
+    private init() {}
+    
+    func clearAllBorders() {
+        for window in borderWindows {
+            window.orderOut(nil)
+        }
+        borderWindows.removeAll()
+    }
+    
+    func createBorderForRect(_ rect: Rect, color: NSColor = .orange, thickness: CGFloat = 5.0) {
+        // Create four windows for each side of the rectangle
+        createBorderSide(rect, .top, color, thickness)
+        createBorderSide(rect, .right, color, thickness)
+        createBorderSide(rect, .bottom, color, thickness)
+        createBorderSide(rect, .left, color, thickness)
+    }
+    
+    private enum BorderSide {
+        case top, right, bottom, left
+    }
+    
+    private func createBorderSide(_ rect: Rect, _ side: BorderSide, _ color: NSColor, _ thickness: CGFloat) {
+        var borderRect = NSRect.zero
+        
+        switch side {
+        case .top:
+            borderRect = NSRect(x: rect.topLeftX, y: rect.topLeftY - thickness, width: rect.width, height: thickness)
+        case .right:
+            borderRect = NSRect(x: rect.topLeftX + rect.width, y: rect.topLeftY - rect.height, width: thickness, height: rect.height)
+        case .bottom:
+            borderRect = NSRect(x: rect.topLeftX, y: rect.topLeftY - rect.height, width: rect.width, height: thickness)
+        case .left:
+            borderRect = NSRect(x: rect.topLeftX - thickness, y: rect.topLeftY - rect.height, width: thickness, height: rect.height)
+        }
+        
+        let window = NSWindow(
+            contentRect: borderRect,
+            styleMask: .borderless,
+            backing: .buffered,
+            defer: false
+        )
+        
+        window.backgroundColor = color
+        window.isOpaque = false
+        window.hasShadow = false
+        window.level = .floating
+        window.ignoresMouseEvents = true
+        
+        // Make the window visible
+        window.orderFront(nil)
+        
+        // Store the window
+        borderWindows.append(window)
+    }
+}
+
+// Helper function to create a border for a rectangle
+func createBorder(for rect: Rect, color: NSColor = .orange, thickness: CGFloat = 5.0) {
+    BorderManager.shared.createBorderForRect(rect, color: color, thickness: thickness)
+}
+
+// Helper function to clear all borders
+func clearAllBorders() {
+    BorderManager.shared.clearAllBorders()
+} 
\ No newline at end of file
diff --git a/Sources/Common/cmdArgs/cmdArgsManifest.swift b/Sources/Common/cmdArgs/cmdArgsManifest.swift
index dc4aae2..7389b6e 100644
--- a/Sources/Common/cmdArgs/cmdArgsManifest.swift
+++ b/Sources/Common/cmdArgs/cmdArgsManifest.swift
@@ -29,6 +29,7 @@ public enum CmdKind: String, CaseIterable, Equatable {
     case moveNodeToMonitor = "move-node-to-monitor"
     case moveNodeToWorkspace = "move-node-to-workspace"
     case moveWorkspaceToMonitor = "move-workspace-to-monitor"
+    case notionSplit = "notion-split"
     case reloadConfig = "reload-config"
     case resize
     case split
@@ -105,6 +106,8 @@ func initSubcommands() -> [String: any SubCommandParserProtocol] {
                 result[kind.rawValue] = SubCommandParser(parseWorkspaceToMonitorCmdArgs)
                 // deprecated
                 result["move-workspace-to-display"] = SubCommandParser(MoveWorkspaceToMonitorCmdArgs.init)
+            case .notionSplit:
+                result[kind.rawValue] = SubCommandParser(parseNotionSplitCmdArgs)
             case .reloadConfig:
                 result[kind.rawValue] = SubCommandParser(ReloadConfigCmdArgs.init)
             case .resize:
diff --git a/Sources/Common/cmdArgs/impl/NotionSplitCmdArgs.swift b/Sources/Common/cmdArgs/impl/NotionSplitCmdArgs.swift
new file mode 100644
index 0000000..fa22434
--- /dev/null
+++ b/Sources/Common/cmdArgs/impl/NotionSplitCmdArgs.swift
@@ -0,0 +1,36 @@
+import Foundation
+
+public struct NotionSplitCmdArgs: CmdArgs {
+    public let rawArgs: EquatableNoop<[String]>
+    fileprivate init(rawArgs: [String]) { self.rawArgs = .init(rawArgs) }
+    public static let parser: CmdParser<Self> = cmdParser(
+        kind: .notionSplit,
+        allowInConfig: true,
+        help: "Split the screen in Notion WM style",
+        options: [
+            "--window-id": optionalWindowIdFlag(),
+        ],
+        arguments: [newArgParser(\.arg, parseNotionSplitOrientation, mandatoryArgPlaceholder: NotionSplitOrientation.unionLiteral)]
+    )
+
+    public var arg: Lateinit<NotionSplitOrientation> = .uninitialized
+    public var windowId: UInt32?
+    public var workspaceName: WorkspaceName?
+
+    public init(rawArgs: [String], _ arg: NotionSplitOrientation) {
+        self.rawArgs = .init(rawArgs)
+        self.arg = .initialized(arg)
+    }
+
+    public enum NotionSplitOrientation: String, CaseIterable {
+        case horizontal, vertical
+    }
+}
+
+public func parseNotionSplitCmdArgs(_ args: [String]) -> ParsedCmd<NotionSplitCmdArgs> {
+    parseSpecificCmdArgs(NotionSplitCmdArgs(rawArgs: args), args)
+}
+
+private func parseNotionSplitOrientation(arg: String, nextArgs: inout [String]) -> Parsed<NotionSplitCmdArgs.NotionSplitOrientation> {
+    parseEnum(arg, NotionSplitCmdArgs.NotionSplitOrientation.self)
+} 
\ No newline at end of file
diff --git a/current diff changes from repo b/current diff changes from repo
new file mode 100644
index 0000000..4f59c73
--- /dev/null
+++ b/current diff changes from repo	
@@ -0,0 +1 @@
+git diff
-- 
2.39.5 (Apple Git-154)

